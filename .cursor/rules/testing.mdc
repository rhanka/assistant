# Testing Strategy

## Overview
This document defines the testing strategy for the assistant project, ensuring all testing goes through the Makefile (Docker-first approach) with optimized CI workflows.

## Testing Principles
- **Test behavior, not implementation** - Focus on what users see/do
- **Use descriptive test names** - "should [behavior] when [condition]"
- **Query by user-visible elements** - text, roles, labels over test IDs
- **Keep tests isolated** - Independent and repeatable
- **70% unit, 20% integration, 10% E2E** - Test pyramid

## Testing Levels

### 1. Unit Tests
- **Scope**: Individual functions, classes, and components
- **Environment**: Isolated, no external dependencies
- **Execution**: Via `make test.unit.<package>`

### 2. Integration Tests (Peer-to-Peer)
- **Scope**: Component with its direct dependencies (DB, Redis)
- **Environment**: Real services (PostgreSQL, Redis) but isolated from other components
- **Execution**: Via `make test.integration.<component1>-<component2>`

### 3. End-to-End Tests
- **Scope**: Full user workflows across multiple components
- **Environment**: Complete stack with real services
- **Execution**: Via `make test.e2e.<scenario>`

## CI/CD Testing Strategy

### Updated CI Pipeline (High-Level)
1) Build images (block on Critical/High dependency vulns inside Dockerfiles)
- Node: run `npm audit --audit-level=high` in base and production stages
- Python: consider `pip-audit --strict` (or defer to Snyk in CI)
- Tag and push images to GHCR (e.g., `ghcr.io/<org>/<repo>/<service>:<sha>`) for reuse

2) In parallel after build
- Unit tests per service (`make test.unit.*`), unchanged
- Security scans (Snyk/Trivy in parallel)
  - Snyk Code (source), Snyk Deps (manifests), Snyk IaC (compose/k8s)
  - Snyk Container + Trivy Image on built images

3) After unit tests of involved services
- Run P2P integration tests (`make test.integration.*`)

4) E2E tests (to be)
- Run after integration, if applicable

### High-Level DAG (dependencies)
- 1.0: Build images (with dependency audits) → 1.1: Store/push images (GHCR)
- 1.1 → 2.0: Run Unit Tests per service (parallel)
- 1.1 → 4.0: Run Security Scans (Snyk Code/Deps/IaC + Snyk Container, Trivy) (parallel)
- 2.0 → 3.0: Run P2P Integration Tests for service pairs that passed unit tests
- 3.0 → E2E (if applicable)

### Path-Based Triggers and Dependencies
- Build job runs when any service or global config changes
- Unit jobs depend on build (images available, tests targets unchanged)
- Security jobs depend on build
- Integration jobs depend on unit jobs for involved services

## Make Commands (Documentation)

### Package-Specific Tests (unchanged)
```makefile
# Unit tests
test.unit.api: docker compose run --rm api npm run test:unit
test.unit.ui: docker compose run --rm ui npm run test:unit
test.unit.scheduler: docker compose run --rm scheduler npm run test:unit
test.unit.workers: docker compose run --rm workers npm run test:unit
test.unit.ai: docker compose run --rm ai pytest tests/

# Integration tests
test.integration.api: docker compose run --rm api npm run test:integration
test.integration.workers-api: docker compose run --rm workers npm run test:integration

# E2E tests
test.e2e.ui: docker compose run --rm ui npm run test:e2e
test.e2e.ui-api: docker compose run --rm ui npm run test:e2e:integration
```

### Security Tests (naming only — implemented in Makefile)
```makefile
# Aggregates
test.security: test.security.scan test.security.container
test.security.scan: test.security.scan.deps test.security.scan.code test.security.scan.iac
test.security.container: test.security.container.snyk.all test.security.container.trivy.all

# Dependency scans (per service) — depend on image build targets
test.security.scan.deps.api|ui|workers|scheduler|ai  # should run after build.<service>

# Code scan (source)
test.security.scan.code

# IaC scan (compose/k8s)
test.security.scan.iac

# Container scans (per service)
test.security.container.snyk.<service> and .all
test.security.container.trivy.<service> and .all
```

## Testing Frameworks

### Framework Selection
- **UI (SvelteKit)**: Use **Vitest** for unit tests (modern, Vite-native)
- **API (NestJS)**: Use **Vitest** for unit tests (TypeScript-first, ESM support)
- **Scheduler/Workers**: Use **Vitest** for unit tests (consistency with other packages)
- **AI (Python)**: Use **pytest** for unit tests (Python standard)
- **E2E**: Use **Playwright** for browser automation

### Framework Rationale
- **Vitest**: Better TypeScript/ESM support, faster than Jest, Vite-native
- **pytest**: Python standard, extensive ecosystem
- **Playwright**: Modern browser automation, better than Selenium

## Testing Rules

### 1. No Test Duplication
- **Unit tests**: Always executed for changed components
- **Integration tests**: Only in component-specific workflows
- **E2E tests**: Only in integration workflows, replacing component integration tests

### 2. Dependency Awareness
- **Independent components**: Test in isolation
- **Dependent components**: Include dependency tests
- **P2P workflows**: Focus on integration/E2E, assume dependencies are already tested
- **Configuration changes**: Trigger all relevant workflows

### 3. Performance Optimization
- **Path-based triggers**: Only test what changes
- **Parallel execution**: Independent workflows run simultaneously
- **Caching**: Leverage Docker layer caching and test result caching

### 4. Quality Gates
- **All unit tests must pass** before integration tests
- **Integration tests must pass** before E2E tests
- **P2P workflows focus on integration**: Unit tests handled by component workflows
- **Global validation** required for configuration changes

## Implementation Notes

### GitHub Actions Best Practices
- Use `pull_request` trigger for path-based filtering
- Include all necessary configuration files in path filters
- Separate workflows by functional domain
- Use matrix strategies for parallel testing where possible

### Docker-First Approach
- All tests run in Docker containers
- Use `docker compose run --rm` for test execution
- Leverage Docker layer caching for faster builds
- Ensure consistent test environment across CI and local

### Make-First Architecture
- All test commands go through Makefile
- No direct `npm`, `pytest`, or `docker` commands in CI
- Centralized test configuration and execution
- Consistent interface for local and CI testing
description:
globs:
alwaysApply: false
---
